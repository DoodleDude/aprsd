/* 
 * Copyright (C) 2002 by LA7ECA, ï¿½yvind Hanssen (ohanssen@acm.org)
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */
 
package aprs;
import uk.me.jstott.jcoord.*; 
import java.util.*;
import java.io.Serializable;
  
  
  
public class Station implements Serializable
{

public static class Status implements Serializable
{
    public Date time;
    public String text;
    public Status(Date t, String txt)
      { time = t; text = txt; }
}


    /*
     * Static variables and functions to control expire timeouts 
     * and notifications
     */
    private static long _expiretime    = 1000 * 60 * 60;    // Default: 1 hour
    private static long _nonMovingTime = 1000 * 60 * 5;      // 5 minutes  
    private static SymTable _symTab    = new SymTable ("symbols");
    private static ColourTable _colTab = new ColourTable ("trailcolours");
    
    
    private static Notifier _change = new Notifier();
    
    public static void waitChange()
       { waitChange(null, null); }
       
    public static void waitChange(UTMRef uleft, UTMRef lright) 
       { _change.waitSignal(uleft, lright); } 
    
    
    public static long getExpiretime()
       { return _expiretime; }
    
         
    public static void setExpiretime(long exp)
       { _expiretime = exp; }


    /*
     * Attributes of a station record (APRS data)
     */
    private String      _callsign; 
    private String      _description;
    private Status      _status;
    private Reference   _position;  
    private int         _course;
    private int         _speed; 
    private int         _altitude;   
    private char        _symbol; 
    private boolean     _altsym; 
    private History     _history = new History(); 
    
    /* 
     * Other variables (presentation, storage, etc.)
     */
    private String      _alias;  
    private String      _icon; 
    private String[]    _trailcolor = new String[] {"dddddd","ff0000"};
    private boolean     _autotrail = true;
    private boolean     _hidelabel = false; 
    private Date        _updated, _lastMoved;
    private boolean     _expired = false; 
    private boolean     _moving = false;      
    private boolean     _permanent = false; 
    private int         _report_ignored = 0;

    private HashSet<Station> _heard;       
       
    public Station(String id)
       { _callsign = id;        
         _updated = new Date(); 
       }
        
        

    public void addHeard(Station s)
    { 
       if (_heard == null) _heard = new HashSet();
       _heard.put(s);
    }


    /**
     * Test if position is inside of the rectangular area defined by uleft (upper left corner)
     * and lright (lower right corner). Assume that uleft and lright are the same
     * UTM zone. 
     */          
    public boolean isInside(UTMRef uleft, UTMRef lright)
    {
         /* FIXME: Add lat zone as well */
        if (_position == null)
           return false;
        UTMRef ref = _position.toLatLng().toUTMRef(uleft.getLngZone());
        return ( ref.getEasting() >= uleft.getEasting() && ref.getNorthing() >= uleft.getNorthing() &&
                 ref.getEasting() <= lright.getEasting() && ref.getNorthing() <= lright.getNorthing() );
    }
    
              
    public boolean isPermanent()
       { return _permanent; }
       
    public void setPermanent(boolean p)
       { _permanent = p; }
    
    
    public boolean isLabelHidden()
       { return _hidelabel; }
    
    public synchronized void setLabelHidden(boolean h)
      { if (_hidelabel != h) {
          _hidelabel = h;
          setMoving(); 
        }
      }
       
       
    public synchronized History.Item getHItem()
       { return new History.Item(_updated, _position, _speed, _course); }
       
    public String getId()
       { return _callsign; }
       
    
    public String getAlias()
       { return _alias; }
       
       
    private static boolean changeOf(String x, String y)
    {
        return x != y || (x != null && !x.equals(y)); 
    }   
    
    
    public synchronized void setAlias(String a)
    {  
      if (changeOf(_alias, a)) {
        _alias = a;
         setMoving(); 
      }
    }
    
    public void setStatus(Date t, String txt)
    {
        if (t==null)  
           t = new Date(); 
        _status = new Status(t, txt);
    }
    
    /* Vi kan kanskje legge inn en sjekk om statusrapporten er for gammel */
    public Status getStatus()
        { return _status; }
    
    
    public synchronized History getHistory() 
        { return _history; }        
      
    public boolean iconIsNull()
       { return _icon == null; }
       
       
    public String getIcon()
    { 
       if (_icon != null)
          return _icon; 
       return _symTab.getIcon(_symbol, _altsym);
    }           
        
    public synchronized void setIcon(String a)
    {  
      if (changeOf(_icon, a)) {
        _icon = a;
        setMoving(); 
      }
    }
    
       
    public boolean isAutoTrail()
       { return _autotrail; }  
       
    public String[] getTrailColor()
       { return _trailcolor;}


    public void nextTrailColor()
       { _trailcolor = _colTab.nextColour(); setMoving(); }
       
             
    public Reference getPosition ()   
       { return _position; } 
       
    public int getSpeed ()
       { return _speed; }
       
    public int getCourse ()
       { return _course; }
       
    public int getAltitude()
       { return _altitude; }
          
    public String getDescr()
       { return (_description == null ? "" : _description); }
       
       
    public synchronized void setDescr(String d)
    {   
        if (d != null) 
        {
           if ((_description==null && d!=null) || (_description != null && !_description.equals(d)))
               setMoving(); 
           _description = d;  
        }
    }
              
       
    public Date getUpdated()
       { return _updated; }
       
       
       
          
    public synchronized void update(Date ts, Reference newpos, int crs, int sp, int alt, String descr, char sym, boolean altsym)
    { 
        if (_position != null && _updated != null)
        { 
           /* Distance in meters */
           long distance = Math.round(_position.toLatLng().distance(newpos.toLatLng()) * 1000); 
           
           if (ts != null)
           {
              /* Time distance in seconds */
              long tdistance = (ts.getTime() - _updated.getTime()) / 1000;          
               
              /*
               * If distance/time implies a speed more than a certain limit (500km/h), 
               * ignore the report. But not more than 3 times. 
               * FIXME: speed limit should be configurable.
               */
              if ( _report_ignored < 3 && tdistance > 0 && 
                    distance/tdistance > (500 * 0.27778)) 
              {
                 System.out.println("*** Ignore report moving beyond speed limit (500km/h)");
                 _report_ignored++;
                 return;
              }
           }
           if (getHistory().hasDuplicate(5, newpos, sp)) {
               System.out.println("*** Ignore report - duplicate");
               return;
           }               
           _report_ignored = 0;
                       
           
           /*
            * If distance is more than a certain threshold, indicate that object is moving/changing, 
            * save the previous position.
            */
           if ( distance > 10)  // Distance threshold. FIXME: Should be configurable
           {   
               if (getHistory().isEmpty() && _autotrail)
                   _trailcolor = _colTab.nextColour();
               _history.add(_updated, _position, _speed, _course); 
               setMoving();
           }
        }
        if (_position == null)
            setMoving();
            
        setDescr(descr); 
        _updated = (ts == null ? new Date() : ts);   
        
        _position = newpos;
        _speed = sp;
        _course = crs;
        _altitude = alt;
        
        if (_expired) {
            _expired = false;
            setMoving();
        }
        
        if (sym != _symbol || altsym != _altsym)
        {
            _symbol = sym;
            _altsym = altsym;
            setMoving();
        }
        
        isMoving(); 
    }
    


    public synchronized void setMoving()
    {
         _moving = true;
         _lastMoved = _updated;  
        _change.signal(this); 
    }
           
      
      
    /*
     * This must also be called periodically to ensure that asyncronous waiters
     * are updated when a station has stopped updating. 
     */ 
    public synchronized boolean isMoving() 
    {
          /* 
           * When station has not changed position or other properties for xx minutes, 
           * it is regarded as not moving. 
           */
          if (_moving && _updated.getTime() > _lastMoved.getTime() + _nonMovingTime) {
               _change.signal(this);
               return (_moving = false);
          }
          return _moving; 
    }
       
    
    
    public synchronized boolean expired()
    {
        Date now = new Date(); 
        if (_expired) 
            return true; 
        if (now.getTime() <= _updated.getTime() + _expiretime)  // If expired
            return false;
        return (_expired = true); 
        
    }
    

}
